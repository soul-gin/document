水平拆分 : APP --> NG --> 网关层 --> 消息队列(异步增加吞吐量,针对一致性要求不高的写请求,读请求是无法通过消息队列处理的,总不能查询数据结果返回查询请求已发送吧)层 --> 业务逻辑层 --> 公共逻辑层(将其他模块均要使用到的业务逻辑层抽取出来,下层成为公共逻辑层,公共逻辑层是不能反向调用业务逻辑层的) --> 数据访问层 --> 数据存储层
SOA水平+垂直拆分 : 按照功能进行拆分,音视频模块 消息模块  登录模块,如消息模块这种公共底层组件的开发组比较忙碌时,如果音视频模块的新增需求需要消息模块配合修改,那么就难以协调
微服务水平+垂直拆分 : 按职能拆分(以前公司分 前端 后台 测试,现在改成 每个功能模块小组都有自己的前端 后台 测试,这样就不容易有前后端 测试大组之间的扯皮,而是小团队之间的分工协作,这也是目前主流公司组织架构变化趋势,类似微服务的拆分思想),即音视频模块就集成了消息模块,因音视频对消息依赖本身就很大,之后大需求变动只需要在自己的模块开发即可,不需要其他模块组成员配合


消息队列操作为什么比数据库快?
消息队列是通过一直append追加日志的形式的一种顺序写和顺序读
而数据库则大部分都是随机写和随机读


基于redis的分布式锁能保证一致性么?
基本生产上的redis都是redis集群,主要是为了保证其可用性,所以这是个A模型的中间间,使用A模型来保证C,本身就是错误的(一般会有主备,主redis挂掉的时候,里面的锁的key还未复制到从节点,此时从节点转换成了主节点,就会导致分布式锁出问题,不能锁成功,虽然概率很低,可用于一致要求不高或者幂等性操作)
所以如果想要保证一致性的分布式锁,那么就应该使用zk(paxos算法实现)这种C模型的中间件


ceph
linux下的分布式存储解决方案,使用了CRUSH算法、HASH环等方法，使得它不存在传统的单点故障的问题，且随着规模的扩大性能并不会受到影响。


通过消息队列异步解耦push还是pull
在消息量很大的情况下如果使用push,消费端处理性能不一定跟的上,所以pull的方式可根据服务端的消费情况进行消费



