
互联网企业,瓶颈点:高并发
集群,高可用,异地多活

针对服务:
有状态服务,需要维护session,在集群环境下,共享session存在同步数据问题,单台挂掉重启存在短暂数据不一致情况
(redis 做共享session,比单纯依靠各个服务端的tomcat共享session效率更高,但本质是ap模型,在业务不是很苛刻情况下可使用,
主从切换时可能存在数据丢失情况)
无状态服务,无需记录状态,便没有要处理共享资源的问题

针对请求,如果能幂等,尽量幂等(类似登录状态维护,如果有app端,app端也是可以持续一段时间来保持登录,在app端够安全情况下)
幂等性:同一个请求多次到后端服务,均处理后,结果是一致的(类似函数的概念,入参一致,结果一致,不论执行多少次)

幂等数据库操作:
	查询;
	insert into user values("","") where uid = xxx;
	update user set age = 19 where uid = xxx;  (绝对值操作)
	delete from user where uid in(uid100,...uid1);  (先查询出对应id,再进行删除)
非幂等数据库操作: 
	insert into user values("","");
	update user set age = (age + 1) where uid = xxx;  (相对值操作)
	delete from user limit 100;  (直接删除100个)

当服务无法做成幂等性时:
分布式锁 + 状态字段
例:从MQ中取order消息,处理订单流程,使用对应orderId作为锁的key,执行完成将订单状态改成已执行

redis实现分布式锁(cp模型,要求不高可使用)
zookeeper实现(较为繁琐 cp模型)
etcd(推荐 一般使用cp模型,支持ap模型)


分布式事务
XA模型数据库实现,会锁定多个库,一般为表级锁,针对长流程业务时,包含在事务内的多个涉及表均会被锁定,导致数据库性能下降较多

TCC模型:失败后通过补偿事务进行回滚,当事务中涉及系统很多时,比如N个,则需要N-1个补偿事务,过于繁琐,侵入业务代码

MQ+数据库(TCC try confirm cancel)实现
将其他系统的事务,写成一条消息,插入本地数据库(id,content,toipc,status),然后对这两个操作开启一个事务;
再通过MQ读取该消息,并将该orderid设置为分布式锁的key(避免重复消费),该消息发送后修改数据库状态为半执行,
等其他系统处理完成,并返回处理结果后
1.成功: 删除数据库中该消息
2.失败,重试一定次数后,仍未成功则记录日志,人工处理(补偿事务较少的情况下可以写补偿事务,当链路过长补偿事务很多,严重侵入业务)
同时需要定时检查数据库中的消息执行状态是否有长时间均是半执行的,如果有则需要让MQ重新发送(避免其他系统接收后丢消息问题)


















